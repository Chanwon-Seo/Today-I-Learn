# 객체지향 쿼리 언어 소개

- JPQL
- JPA Criteria
- QueryDSL
- 네이티브 SQL
- JDBC API 직접 사용, MyBatis, SpringJdbcTemplate 함께 사용

## JPQL 소개

- 가장 단순한 조회 방법
  - EntityManager.find()
  - 객체 그래프 탐색(a.getB().getC())
- **나이가 18살 이상인 회원을 모두 검색하고 싶다면?**

## JPQL

- JPA를 사용하면 엔티티 객체를 중심으로 개발
- 문제는 검색 쿼리
- 검색을 할 때도 **테이블이 아닌 엔티티 객체를 대상으로 검색**
- 모든 DB 데이터를 객체로 변환해서 검색하는 것은 불가능
- 애플리케이션이 필요한 데이터만 DB에서 불러오려면 결국 검색 조건이 포함된 SQL이 필요
- JPA는 SQL을 추상화한 JPQL이라는 객체 지향 쿼리 언어 제공
- SQL과 문법 유사, SELECT, FROM, WHERE, GROUP BY, HAVING, JOIN 지원
- JPQL은 엔티티 객체를 대상으로 쿼리
- SQL은 데이터베이스 테이블을 대상으로 쿼리

## JPQL과 실행된 SQL

### JpaMain.java

```java
try {
        List<Member> result = em.createQuery("SELECT M FROM Member M WHERE M.username like '%kim%'", Member.class)
            .getResultList();

        for (Member member : result) {
            System.out.println("member = " + member);
        }

        tx.commit();
}
```

> 단점: 단순 String이기 때문에 동적 쿼리에 유지보수가 힘들다.<br> 조건을 통해서 + 연산자로 기능을 덧붙여야 한다.

```sql
Hibernate:
    /* SELECT
        M
    FROM
        Member M
    WHERE
        M.username like '%kim%' */ select
            member0_.MEMBER_ID as MEMBER_I1_6_,
            member0_.city as city2_6_,
            member0_.street as street3_6_,
            member0_.zipcode as zipcode4_6_,
            member0_.USERNAME as USERNAME5_6_
        from
            Member member0_
        where
            member0_.USERNAME like '%kim%'
```

- 테이블이 아닌 객체를 대상으로 검색하는 객체 지향 쿼리
- SQL을 추상화해서 특정 데이터베이스 SQL에 의존 X
- JPQL을 한마디로 정의하면 객체 지향 SQL

## Criteria 소개

- 문자가 아닌 자바코드로 JPQL을 작성할 수 있음
- JPQL 빌더 역할
- JPA 공식 기능
- <span style="color:red">단점 : 너무 복잡하고 실용성이 없다.</span>
- Criteria 대신에 QueryDSL 사용 권장

![image](https://user-images.githubusercontent.com/90185805/153226023-1995caf8-18bd-45c9-b8ca-57ad4e4bc120.png)

## QueryDSL 소개

- 문자가 아닌 자바코드로 JPQL을 작성할 수 있음
- JPQL 빌더 역할
- 컴파일 시점에 문법 오류를 찾을 수 있음
- 동적쿼리 작성 편리함
- **단순하고 쉬움**
- <span style="color:skyblue">실무 권장 사용</span>

```java
    //JPQL
    //select m from Member m where m.age > 18
    JPAFactoryQuery query = new JPAQueryFactory(em);

    QMember m = QMember.member;
    List<Member> result = queryFactory
                .select(m)
                .from(m)
                .where(m.name.like("kim"))
                .orderBy(m.id.desc())
                .fetch();
```

## 네이티브 SQL 소개

- JPA가 제공하는 SQL을 직접 사용하는 기능
- JPQL로 해결할 수 없는 특정 데이터베이스에 의존적인 기능
- 예) 오라클 CONNECT BY, 특정 DB만 사용하는 SQL 힌트(하이버네이트가 데이터베이스 방언으로 지원도 함)

```java
    String sql =
        "SELECT ID, AGE, TEAM_ID, NAME FROM MEMBER WHERE NAME = 'kim'";

    List<Member> resultList =
                    em.createNativeQuery(sql, Member.class).getResultList();
```

## JDBC 직접 사용, SpringJdbcTemplate 등

- JPA를 사용하면서 JDBC 커넥션을 직접 사용하거나, 스프링 JdbcTemplate, 마이바티스등을 함께 사용 가능
- 단 영속성 컨텍스트를 적절한 시점에서 강제로 플러시 필요
- 예) JPA를 우회해서 SQL을 실행하기 직전에 영속성 컨텍스트 수동 플러시

---

# JPQL(Java Persistence Query Language)

## JPQL - 기본 문법과 쿼리 API

- JPQL은 객체지향 쿼리 언어다. 따라서 테이블을 대상으로 쿼리하는 것이 아니라. **엔티티 객체를 대상으로 쿼리**한다.
- JPQL은 SQL을 추상화해서 특정데이터베이스 SQL에 의존하지 않는다.
- JPQL은 결국 SQL로 변환된다.

### 모델

![image](https://user-images.githubusercontent.com/90185805/153233677-cf9f20a9-f2b9-4221-883c-65b86b32cc7b.png)

### Member.class

```java
@Entity
public class Member {

    @Id
    @GeneratedValue
    private Long id;
    private String username;
    private int age;

    @ManyToOne
    @JoinColumn(name = "TEAM_ID")
    private Team team;
    //Getter, Setter...
}
```

### Team.class

```java
@Entity
public class Team {

    @Id @GeneratedValue
    private Long id;
    private String name;

    @OneToMany(mappedBy = "team")
    private List<Member> members = new ArrayList<>();
    //Getter, Setter...
}

```

### Order.class

```java
@Entity
@Table(name = "ORDERS")
public class Order {

    @Id
    @GeneratedValue
    private Long id;
    private int orderAmount;

    @Embedded
    private Address address;

    @ManyToOne
    @JoinColumn(name = "PRODUCT_ID")
    private Product product;
    //Getter, Setter...
}
```

### Address.class

```java
@Embeddable
public class Address {
    private String city;
    private String street;
    private String zipcode;
    //Getter, Setter...
}
```

### Product.class

```java
@Entity
public class Product {

    @Id @GeneratedValue
    private Long id;
    private String name;
    private int price;
    private int stockAmount;
    //Getter, Setter...
}
```

### JPQL 문법

## ![image](https://user-images.githubusercontent.com/90185805/153233775-60e47e47-03a9-4763-a2ea-19b40dc1a8c3.png)

- select m from **Member** as m where **m.age** > 18
- 엔티티와 속성은 대소문자 구분한다. (Member, age)
- JPQL 키워드는 대소문자 구분 X (SELECT, FROM, where)
- 엔티티 이름 사용, 테이블 이름이 아님(Member)
- **별칭은 필수(m)**(as는 생략가능)

### 집합과 정렬

## ![image](https://user-images.githubusercontent.com/90185805/153234214-5705ae46-e19e-4706-9689-f69022c24d7f.png)

- GROUP BY, HAVING
- ORDER BY

### TypeQuery, Query

- TypeQuery : **반환 타입이 명확할 때 사용**
- Query : **반환 타입이 명확하지 않을 때 사용**
  ![image](https://user-images.githubusercontent.com/90185805/153234393-5d52563e-a0d9-47ff-bdac-028577e19c4e.png)

### 결과 조회 API

- query.getResultList(): **결과가 하나 이상일 때**, 리스트 반환

  - 결과가 없으면 빈 리스트 반환

  ```java
  try {
            Member member = new Member();
            member.setUsername("member1");
            member.setAge(10);
            em.persist(member);

            TypedQuery<Member> query = em.createQuery("select m from Member m", Member.class);
            List<Member> resultList = query.getResultList();

            for (Member member1 : resultList) {
                System.out.println("member1 = " + member1);
            }

            tx.commit();
        }
  ```

- query.getSingleResult(): **결과가 정확히 하나**, 단일 객체 반환

  - 중요!!

    - 결과가 없으면: javax.persistence.NoResultException
    - 둘 이상이면: javax.persistence.NonUniqueResultException

    ```java
        try {
            Member member = new Member();
            member.setUsername("member1");
            member.setAge(10);
            em.persist(member);

            TypedQuery<Member> query = em.createQuery("select m from Member m", Member.class);
            Member result = query.getSingleResult();
            System.out.println("result = " + result);

            tx.commit();
        }
    ```

### 파라미터 바인딩 - 이름 기준, 위치 기준

![image](https://user-images.githubusercontent.com/90185805/153234610-4e175075-6f59-4f1c-bb8e-d9b193666a4b.png)

> 위치 기반의 파라미터 바인딩은 순서가 바뀔 수 있으니 사용하지 말 것.

```java
try {
    Member member = new Member();
    member.setUsername("member1");
    member.setAge(10);
    em.persist(member);

    Member result = em.createQuery("select m from Member m where m.username = :username", Member.class)
              .setParameter("username", "member1")
              .getSingleResult();
    System.out.println("singleResult = " + result.getUsername());

    tx.commit();
}
```

### 프로젝션

- SELECT 절에 조회할 대상을 지정하는 것
- 프로젝션 대상: 엔티티, 임베디드 타입, 스칼라 타입(숫자, 문자등 기본 데이터 타입)
- SELECT m FROM Member m -> 엔티티 프로젝션

  ```java
  try {
              Member member = new Member();
              member.setUsername("member1");
              member.setAge(10);
              em.persist(member);

              em.flush(); //1차 캐시
              em.clear();

              //영속성 컨텍스트에 반영된다.
              List<Member> result = em.createQuery("select m from Member m", Member.class)
                      .getResultList();

              Member findMember = result.get(0);
              findMember.setAge(20);


              tx.commit();
          }
  ```

  ### 결과

  ```sql
  Hibernate:
      /* select
          m
      from
          Member m */ select
              member0_.id as id1_0_,
              member0_.age as age2_0_,
              member0_.TEAM_ID as TEAM_ID4_0_,
              member0_.username as username3_0_
          from
              Member member0_
  Hibernate:
      /* update
          jpql.Member */ update
              Member
          set
              age=?,
              TEAM_ID=?,
              username=?
          where
              id=?
  ```

  > 영속성 컨텍스트에 관린된다.<br>
  > UPDATE SQL문이 나간다.

- SELECT m.team FROM Member m -> 엔티티 프로젝션

  ```java
  try {
            Member member = new Member();
            member.setUsername("member1");
            member.setAge(10);
            em.persist(member);

            em.flush(); //1차 캐시
            em.clear();

            //영속성 컨텍스트에 반영된다.
            //List<Team> result = em.createQuery("select m.team from Member m", Team.class)
            //.getResultList();

            //한 눈에 보기 어렵기 때문에 쿼리를 직접 작성하는 방법이 옳다.
            List<Team> result = em.createQuery("select t from Member m join m.team t", Team.class).getResultList();

            tx.commit();
        }
  ```

  ### 결과

  ```sql
  Hibernate:
    /* select
        m.team
    from
        Member m */ select
            team1_.id as id1_3_,
            team1_.name as name2_3_
        from
            Member member0_
        inner join
            Team team1_
                on member0_.TEAM_ID=team1_.id
  ```

  > join절이 포함되어있다.

- SELECT m.address FROM Member m -> 임베디드 타입 프로젝션

  ```java
  try {
            Member member = new Member();
            member.setUsername("member1");
            member.setAge(10);
            em.persist(member);

            em.flush(); //1차 캐시
            em.clear();

            //영속성 컨텍스트에 반영된다.
            em.createQuery("select o.address from Order o", Address.class)
                    .getResultList();

            tx.commit();
        }
  ```

  ### 결과

  ```sql
  Hibernate:
    /* select
        o.address
    from

    Order o */ select
        order0_.city as col_0_0_,
        order0_.street as col_0_1_,
        order0_.zipcode as col_0_2_ from
            ORDERS order0_
  ```

- SELECT m.username, m.age FROM Member m -> 스칼라 타입 프로젝션

  ```java
  try {
            Member member = new Member();
            member.setUsername("member1");
            member.setAge(10);
            em.persist(member);

            em.flush(); //1차 캐시
            em.clear();

            //영속성 컨텍스트에 반영된다.
            em.createQuery("select distinct m.username, m.age from Member m")
                    .getResultList();

            tx.commit();
  }
  ```

  ### 결과

  ```sql
  Hibernate:
    /* select
        distinct m.username,
        m.age
    from
        Member m */ select
            distinct member0_.username as col_0_0_,
            member0_.age as col_1_0_
        from
            Member member0_
  ```

  > 문제! username과 age의 타입을 어떻게 가져와야 하는지 고민해봐야 한다.
  > 바로 다음 장 프로젝션 - 여러 값 조회에서 알 수 있다.

- DISTINCT로 중복 제거

### 프로젝션 - 여러 값 조회

- SELECT m.username, m.age FROM Member m
- 1. Query 타입으로 조회

  ```java
  try {
              Member member = new Member();
              member.setUsername("member1");
              member.setAge(10);
              em.persist(member);

              em.flush(); //1차 캐시
              em.clear();

              //영속성 컨텍스트에 반영된다.
              List resultList = em.createQuery("select distinct m.username, m.age from Member m")
                      .getResultList();

              Object o = resultList.get(0);
              Object[] result = (Object[]) o;
              System.out.println("username = " + result[0]);
              System.out.println("age = " + result[1]);

              tx.commit();
          }
  ```

  ### 결과

  ```sql
  Hibernate:
      /* select
          distinct m.username,
          m.age
      from
          Member m */ select
              distinct member0_.username as col_0_0_,
              member0_.age as col_1_0_
          from
              Member member0_
  username = member1
  age = 10
  ```

- 2. Object[] 타입으로 조회

  ```java
  try {
            Member member = new Member();
            member.setUsername("member1");
            member.setAge(10);
            em.persist(member);

            em.flush(); //1차 캐시
            em.clear();

            //영속성 컨텍스트에 반영된다.
            List<Object[]> resultList = em.createQuery("select distinct m.username, m.age from Member m")
                    .getResultList();

            Object[] result = resultList.get(0);
            System.out.println("username = " + result[0]);
            System.out.println("age = " + result[1]);

            tx.commit();
        }
  ```

  ### 결과

  ```sql
  Hibernate:
    /* select
        distinct m.username,
        m.age
    from
        Member m */ select
            distinct member0_.username as col_0_0_,
            member0_.age as col_1_0_
        from
            Member member0_
  username = member1
  age = 10
  ```

- 3. new 명령어로 조회

  - 단순 값을 DTO로 바로 조회
  - SELECT new jpabook.jpql.UserDTO(m.username, m.age) FROM Member m
  - 패키지 명을 포함한 전체 클래스 명 입력
  - **순서와 타입이 일치하는 생성자 필요**

  ### MemberDTO.class

  ```java
  package jpql;

  public class MemberDTO {
      private String username;
      private int age;

      //생성자
      public MemberDTO(String username, int age) {
          this.username = username;
          this.age = age;
      }
      //Getter, Setter...
  }
  ```

  ```java
  try {
            Member member = new Member();
            member.setUsername("member1");
            member.setAge(10);
            em.persist(member);

            em.flush(); //1차 캐시
            em.clear();

            List<MemberDTO> result = em.createQuery("select new jpql.MemberDTO(m.username, m.age) from Member m", MemberDTO.class)
                    .getResultList();

            MemberDTO memberDTO = result.get(0);
            System.out.println("memberDTO = " + memberDTO.getUsername());
            System.out.println("memberDTO = " + memberDTO.getAge());

            tx.commit();
        }
  ```

  ### 결과

  ```sql
  Hibernate:
      /* select
          new jpql.MemberDTO(m.username,
          m.age)
      from
          Member m */ select
              member0_.username as col_0_0_,
              member0_.age as col_1_0_
          from
              Member member0_
  memberDTO = member1
  memberDTO = 10
  ```

### 페이징 API

- JPA는 페이징을 다음 두 API로 추상화
- **setFirstResult**(int startPosition) : 조회 시작 위치(0부터 시작)
- **setMaxResult**(int maxResult) : 조회할 데이터 수
- 데이터 방언에 따라 JPA는 쿼리를 작성해준다.

### Member.class

```java
@Override
    public String toString() {
        return "Member{" +
                "id=" + id +
                ", username='" + username + '\'' +
                ", age=" + age +
                //", team=" + team + 지워주기 양방향 에러
                '}';
    }
```

```java
try {
            for (int i = 0; i < 100; i++) {
                Member member = new Member();
                member.setUsername("member" + i);
                member.setAge(i);
                em.persist(member);
            }

            em.flush(); //1차 캐시
            em.clear();

            List<Member> result = em.createQuery("select m from Member m order by m.age desc", Member.class)
                    .setFirstResult(1)
                    .setMaxResults(10)
                    .getResultList();

            System.out.println("result.size = " + result.size());
            for (Member member1 : result) {
                System.out.println("member1 = " + member1);
            }

            tx.commit();
        }
```

### 결과

```sql
Hibernate:
    /* select
        m
    from
        Member m
    order by
        m.age desc */ select
            member0_.id as id1_0_,
            member0_.age as age2_0_,
            member0_.TEAM_ID as TEAM_ID4_0_,
            member0_.username as username3_0_
        from
            Member member0_
        order by
            member0_.age desc limit ? offset ?
result.size = 10
member1 = Member{id=99, username='member98', age=98}
member1 = Member{id=98, username='member97', age=97}
member1 = Member{id=97, username='member96', age=96}
member1 = Member{id=96, username='member95', age=95}
member1 = Member{id=95, username='member94', age=94}
member1 = Member{id=94, username='member93', age=93}
member1 = Member{id=93, username='member92', age=92}
member1 = Member{id=92, username='member91', age=91}
member1 = Member{id=91, username='member90', age=90}
member1 = Member{id=90, username='member89', age=89}
```

---

### 조인

- 내부조인(교집합) :

  - SELECT m FROM Member m[INNER] JOIN.m.team t

    ### Member.class

    ```java
    @Entity
    public class Member {

        @Id
        @GeneratedValue
        private Long id;
        private String username;
        private int age;

        //@ManyToOne
        @ManyToOne(fetch = FetchType.LAZY)
        @JoinColumn(name = "TEAM_ID")
        private Team team;

        //편의 메서드
        public void changeTeam(Team team) {
            this.team = team;
            team.getMembers().add(this);
        }

        @Override
        public String toString() {
            return "Member{" +
                    "id=" + id +
                    ", username='" + username + '\'' +
                    ", age=" + age +
    //                ", team=" + team +
                    '}';
        }
    }
    ```

    ### Team.class

        ```java
        @Entity
        public class Team {

            @Id
            @GeneratedValue
            private Long id;
            private String name;

            @OneToMany(mappedBy = "team")
            private List<Member> members = new ArrayList<>();

            public List<Member> getMembers() {
                return members;
            }

            public void setMembers(List<Member> members) {
                this.members = members;
            }
            //Getter, Setter...
        }
        ```

    ### 결과

        ```java
        try {
            Team team = new Team();
            team.setName("teamA");
            em.persist(team);

            Member member = new Member();
            member.setUsername("member1");
            member.setAge(10);

            member.setTeam(team);

            em.persist(member);

            em.flush(); //1차 캐시
            em.clear();

            //inner 생략 가능
            String query = "select m from Member m inner join m.team";
            List<Member> result = em.createQuery(query, Member.class)
                    .getResultList();

            tx.commit();
        }
        ```

    ```sql
        Hibernate:
        /* select
            m
        from
            Member m
        inner join
            m.team */ select
                member0_.id as id1_0_,
                member0_.age as age2_0_,
                member0_.TEAM_ID as TEAM_ID4_0_,
                member0_.username as username3_0_
            from
                Member member0_
            inner join
                Team team1_
                    on member0_.TEAM_ID=team1_.id

        <!-- 쿼리가 한번 더 나가는 문제 Member.class에서 ManyToOne LAZY설정 -->
        /*Hibernate:
        select
            team0*.id as id1_3_0*,
            team0*.name as name2_3_0*
        from
            Team team0*
        where
            team0*.id=?
        */
    ```

    > inner 생략 가능

- 외부 조인(합집합) :

  - SELECT m FORM Member m LEFT [OUTER] JOIN m.team t

    ### 결과

    ```java
      try {
              Team team = new Team();
              team.setName("teamA");
              em.persist(team);


              Member member = new Member();
              member.setUsername("member1");
              member.setAge(10);

              member.setTeam(team);

              em.persist(member);

              em.flush(); //1차 캐시
              em.clear();

              //outer 생략 가능
              String query = "select m from Member m left outer join m.team";
              List<Member> result = em.createQuery(query, Member.class)
                      .getResultList();

              tx.commit();
          }
    ```

    ```sql
      Hibernate:
      /* select
          m
      from
          Member m
      left outer join
          m.team */ select
              member0_.id as id1_0_,
              member0_.age as age2_0_,
              member0_.TEAM_ID as TEAM_ID4_0_,
              member0_.username as username3_0_
          from
              Member member0_
          left outer join
              Team team1_
                  on member0_.TEAM_ID=team1_.id
    ```

- 세타 조인(조건에 만족하는) :

  - SELECT count(m) FROM Member m, Team t where m.username = t.name

    ### 결과

    ```java
    try {
              Team team = new Team();
              team.setName("teamA");
              em.persist(team);


              Member member = new Member();
              member.setUsername("member1");
              member.setAge(10);

              member.setTeam(team);

              em.persist(member);

              em.flush(); //1차 캐시
              em.clear();

              String query = "select m from Member m, Team t where m.username = t.name";
              List<Member> result = em.createQuery(query, Member.class)
                      .getResultList();

              tx.commit();
          }
    ```

    ```sql
    Hibernate:
      /* select
          m
      from
          Member m,
          Team t
      where
          m.username = t.name */ select
              member0_.id as id1_0_,
              member0_.age as age2_0_,
              member0_.TEAM_ID as TEAM_ID4_0_,
              member0_.username as username3_0_
          from
              Member member0_ cross
          join
              Team team1_
          where
              member0_.username=team1_.name
    ```

    > cross join

### 조인 - ON절

- ON절을 활용한 조인(JPA 2.1부터 지원)

  **1. 조인 대상 필터링**

  - 예) 회원과 팀을 조인하면서, 팀 이름이 A인 팀만 조인

    ```sql
    JPQL:
    SELECT m, t FROM Member m LEFT JOIN m.team t on t.name = 'A'

    SQL:
    SELECT m._, t._ FROM
    Member m LEFT JOIN Team t ON m.TEAM_ID=t.id and t.name='A'
    ```

    ### 결과

    ```java
    try {
            Team team = new Team();
            team.setName("teamA");
            em.persist(team);


            Member member = new Member();
            member.setUsername("member1");
            member.setAge(10);

            member.setTeam(team);

            em.persist(member);

            em.flush(); //1차 캐시
            em.clear();

            String query = "select m from Member m left join m.team t on t.name= 'teamA'";
            List<Member> result = em.createQuery(query, Member.class)
                    .getResultList();

            tx.commit();
        }
    ```

    ```sql
        Hibernate:
    /* select
        m
    from
        Member m
    left join
        m.team t
            on t.name= 'teamA' */ select
                member0_.id as id1_0_,
                member0_.age as age2_0_,
                member0_.TEAM_ID as TEAM_ID4_0_,
                member0_.username as username3_0_
        from
            Member member0_
        left outer join
            Team team1_
                on member0_.TEAM_ID=team1_.id
                and (
                    team1_.name='teamA'
                )
    ```

  **2. 연관관계 없는 엔티티 외부 조인(하이버네이트 5.1부터)**

  - 예) 회원의 이름과 팀의 이름이 같은 대상 외부 조인

    ```sql
     JPQL:
     SELECT m, t FROM
     Member m LEFT JOIN Team t on m.username = t.name

    SQL:
     SELECT m._, t._ FROM
     Member m LEFT JOIN Team t ON m.username = t.name
    ```

    ```java
        try {
            Team team = new Team();
            team.setName("teamA");
            em.persist(team);


            Member member = new Member();
            member.setUsername("teamA");
            member.setAge(10);

            member.setTeam(team);

            em.persist(member);

            em.flush(); //1차 캐시
            em.clear();

            String query = "select m from Member m left join Team t on m.username = t.name";
            List<Member> result = em.createQuery(query, Member.class)
                    .getResultList();

            tx.commit();
        }
    ```

    ```sql
    Hibernate:
    /* select
        m
    from
        Member m
    left join
        Team t
            on m.username = t.name */ select
                member0_.id as id1_0_,
                member0_.age as age2_0_,
                member0_.TEAM_ID as TEAM_ID4_0_,
                member0_.username as username3_0_
        from
            Member member0_
        left outer join
            Team team1_
                on (
                    member0_.username=team1_.name
                )
    ```

### 서브 쿼리

- 나이가 평균보다 많은 회원

  ```sql
  select m from Member m
  where m.age > (select avg(m2.age) from Member m2)
  ```

  > 메인 쿼리와 서브 쿼리에 관계가 없다. <br> 상위에서 만든 Member m을 서브쿼리에 가져가지 않음

- 한 건이라도 주문한 고객

  ```sql
  select m from Member m
  where (select count(o) from Order o where m = o.member) > 0
  ```

  > 메인 쿼리와 서브 쿼리에 관계가 연결되어있다.<br>
  > 성능이 잘 안나옴.

### 서브 쿼리 지원 함수

- [NOT] EXISTS (subquery): 서브쿼리에 결과가 존재하면 참
- {ALL | ANY | SOME} (subquery)
- ALL 모두 만족하면 참
- ANY, SOME: 같은 의미, 조건을 하나라도 만족하면 참
- [NOT] IN (subquery): 서브쿼리의 결과 중 하나라도 같은 것이 있으면 참

### 서브 쿼리 - 예제

- **팀A 소속인 회원**
  ```sql
  select m from Member m
  where exists (select t from m.team t where t.name = ‘팀A')
  ```
- **전체 상품 각각의 재고보다 주문량이 많은 주문들**
  ```sql
  select o from Order o
  where o.orderAmount > ALL (select p.stockAmount from Product p)
  ```
- **어떤 팀이든 팀에 소속된 회원**
  ```sql
  select m from Member m
  where m.team = ANY (select t from Team t)
  ```

### JPA 서브 쿼리 한계

- JPA는 WHERE, HAVING 절에서만 서브 쿼리 사용 가능
- SELECT 절도 가능(하이버네이트에서 지원)
- **중요!! FROM 절의 서브 쿼리는 현재 JPQL에서 불가능**

  - **조인으로 풀 수 있으면 풀어서 해결**

    ![image](https://user-images.githubusercontent.com/90185805/153633839-1cf33268-2599-4026-8d67-2f2eb4aa610e.png)

    > from 절의 서브 쿼리를 작성했을 때 에러나는 모습 <br>
    > 그래도 사용해야 한다면, 어플리케이션에서 조작하는 식 또는 쿼리를 분해해서 2번 날린다.

### JPQL 타입 표현

- 문자 : 'HELLO', 'She''s'
- 숫자 : 10L(Long), 10D(Double), 10F(Float)
- Boolean : TRUE, FALSE
- ENUM: jpabook.MemberType.Admin(패키지명 포함)
- 엔티티 타입 : TYPE(m) = Member(상속 관계에서 사용)

### Member.class

```java
@Entity
public class Member {

    @Id
    @GeneratedValue
    private Long id;
    private String username;
    private int age;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "TEAM_ID")
    private Team team;

    @Enumerated(EnumType.STRING) //EnumType을 STRING으로 고정
    private MemberType type;

    public void changeTeam(Team team) {
        this.team = team;
        team.getMembers().add(this);
    }

    @Override
    public String toString() {
        return "Member{" +
                "id=" + id +
                ", username='" + username + '\'' +
                ", age=" + age +
//                ", team=" + team +
                '}';
    }
    //Getter, Setter...
}
```

### MemberType.class

```java
public enum MemberType {
    ADMIN, USER
}

```

```java
try {
        Team team = new Team();
        team.setName("teamA");
        em.persist(team);


        Member member = new Member();
        member.setUsername("teamA");
        member.setAge(10);
        member.setType(MemberType.ADMIN); //member의 EnumType은 ADMIN

        member.setTeam(team);

        em.persist(member);

        em.flush(); //1차 캐시
        em.clear();

        //Enum 사용 시 패키지명도 포함한다. jpql.MemberType.ADMIN
        // String query = "select m.username, 'HELLO', true From Member m where m.type = jpql.MemberType.ADMIN";
        // List<Object[]> result = em.createQuery(query)
        //         .getResultList();

        //파라미터를 받아 사용해 간결화 할 수 있다.
        String query = "select m.username, 'HELLO', true From Member m " +
                    "where m.type = :userType";
            List<Object[]> result = em.createQuery(query)
                    .setParameter("userType",MemberType.ADMIN)
                    .getResultList();

        for (Object[] objects : result) {
            System.out.println("objects = " + objects[0]);
            System.out.println("objects = " + objects[1]);
            System.out.println("objects = " + objects[2]);
        }

        tx.commit();
}
```

### 결과

```sql
Hibernate:
    /* select
        m.username,
        'HELLO',
        true
    From
        Member m
    where
        m.type = jpql.MemberType.ADMIN */ select
            member0_.username as col_0_0_,
            'HELLO' as col_1_0_,
            1 as col_2_0_
        from
            Member member0_
        where
            member0_.type='ADMIN'
objects = teamA
objects = HELLO
objects = true
```

### JPQL 기타

- SQL과 문법이 같은 식
- EXISTS, IN
- AND, OR, NOT
- -, >, >=, <, <=, <>
- BETWEEN, LIKE, IS NULL

### 조건식 - CASE 식

- 기본 CASE 식
  ```sql
  select
      case when m.age <= 10 then '학생요금'
           when m.age >= 60 then '경로요금'
           else '일반요금'
      end
  from Member m
  ```
- 단순 CASE 식
  ```sql
  select
      case t.name
          when '팀A' then '인센티브100%'
          when '팀B' then '인센티브120%'
          else '인센티브105%'
      end
  from Team t
  ```
- COALESCE : 하나씩 조회해서 null이 아니면 반환
- NULLIF: 두 값이 같으면 null 반환, 다르면 첫번째 값 반환
- 사용자 이름이 없으면 이름 없는 회원을 반환
  ```sql
  select coalscec(m.username, '이름 없는 회원') from Member m
  ```
- 사용자 이름이 '관리자'면 null을 반환하고 나머지는 본인의 이름을 반환
  ```sql
  select NULLIF(m.nsername, '관리자') from Member m
  ```

### JPQL 기본 함수

- CONCAT
- SUBSTRING
- TRIM
- LOWER, UPPER
- LENGTH
- LOCATE
- ABS, SQRT, MOD
- SIZE, INDEX(JPA 용도)

### 사용자 정의 함수 호출

- 하이버네이트는 사용전 방언에 추가해야 한다.
  - 사용하는 DB방언을 상속받고, 사용자 정의 함수를 등록한다.

```sql
select function('group_concat', i.name) from Item i)
```

---

## JPQL - 경로 표현식

- .(점)을 찍어 객체 그래프를 탐색하는 것

![image](https://user-images.githubusercontent.com/90185805/153705840-aabe10fe-5aff-4180-b148-9248815d77cf.png)

### 경로 표현식 용어 정리

- 상태 피드(state field): 단순히 값을 저장하기 위한 필드
  - 예) m.username
- 연관 필드(association field): 연관관계를 위한 필드
  - 단일 값 연관 필드 : @ManyToOne, @OneToOne, 대상이 엔티티(ex: m.team)
  - 컬렉션 값 연관 필드 : @OneToMany, @ManyToMany, 대상이 컬렉션(ex: m.orders)

### 경로 표현식 특징

- 상태 필드(state field): 경로 탐색의 끝, 탐색 X
  ```sql
  Hibernate:
  /* select
      m.username
  from
      Member m */ select
          member0_.username as col_0_0_
      from
          Member member0_
  ```
- 단일 값 연관 경로: 묵시적 내부 조인(inner join) 발생, 탐색 O
  ```sql
  Hibernate:
    /* select
        m.team
    from
        Member m */ select
            team1_.id as id1_3_,
            team1_.name as name2_3_
        from
            Member member0_
        inner join
            Team team1_
                on member0_.TEAM_ID=team1_.id
  ```
- 컬렉션 값 연관 경로: 묵시적 내부 조인 발생, 탐색X
  - FROM 절에서 명시적 조인을 통해 별칭을 얻으면 별칭을 통해 탐색 가능

> 묵시적 조인을 실무에서 쓰지 말 것.

### 상태 필드 경로 탐색

- JPQL : select m.username, m.age from Member m
- SQL : select m.username, m.age from Member m

### 단일 값 연관 경로 탐색

- JPQL : select o.member from Order o
- SQL : select m.from Orders o inner join Memberm on o.member_id = m.id

### 명시직 조인, 묵시적 조인

- 명시적 조인: join 키워드 직접 사용
- select m from Member m **join m.team t**
- 묵시적 조인: 경로 표현식에 의해 묵시적으로 SQL 조인 발생 (내부 조인만 가능)
- select m.team from Member m

### 경로 표현식 - 예제

- select o.member.team from Order o -> 성공
- select t.members from Team -> 성공
- select t.members.username from Team t -> 실패
- select m.username from Team t join t.members m -> 성공
  > 묵시적 조인이 아닌 명시적 조인으로 가져와서 성공

### 경로 탐색을 사용한 묵시적 조인 시 주의사항

- 항상 내부 조인
- 컬렉션은 경로 탐색의 끝, 명시적 조인을 통해 별칭을 얻어야함
- 경로 탐색은 주로 SELECT, WHERE 절에서 사용하지만 묵시적 조인으로 인해 SQL의 FROM (JOIN) 절에 영향을 줌

### 실무 조언

- **가급적 묵시적 조인 대신에 명시적 조인 사용**
- 조인은 SQL 튜닝에 중요 포인트
- 묵시적 조인은 조인이 일어나는 상황을 한눈에 파악하기 어려움

## JPQL - 패치 조인(fetch join)

### 패치 조인(fetch join)

- **실무에서 정말 중요함**
- SQL 조인 종류X
- JPQL에서 **성능 최적화**를 위해 제공하는 기능
- 연관된 엔티티나 컬렉션을 **SQL 한 번에 함께 조회하는 기능**
- join fetch 명령어 사용
- 패치 조인 ::= [ LEFT [OUTER] | INNER ] JOIN FETCH 조인경로

### 엔티티 패치 조인

- 회원을 조회하면서 연관된 팀도 함께 조회(SQL 한 번에)
- SQL을 보면 회원 뿐만 아니라 **팀(T.\*)도 함께 SELECT**
- **[JPQL]**
  - select m from Member m join fetch m.team
- **[SQL]**
  - SELECT M.\*, T.\* FROM MEMBER M <br>
    **INNER JOIN TEAM T** ON M.TEAM_ID=T.ID

![image](https://user-images.githubusercontent.com/90185805/153758763-a4251f24-c452-4953-a990-b2de1ffdf9ed.png)

### 패치 조인 사용 코드

- @ManyToOne, @OneToMany
  ![image](https://user-images.githubusercontent.com/90185805/153760741-7940d88b-c3c4-4391-aba3-a80186ba3c28.png)

```java
try {
            Team teamA = new Team();
            teamA.setName("팀A");
            em.persist(teamA);

            Team teamB = new Team();
            teamB.setName("팀B");
            em.persist(teamB);

            Member member1 = new Member();
            member1.setUsername("회원1");
            member1.setTeam(teamA);
            em.persist(member1);

            Member member2 = new Member();
            member2.setUsername("회원2");
            member2.setTeam(teamA);
            em.persist(member2);

            Member member3 = new Member();
            member3.setUsername("회원3");
            member3.setTeam(teamB);
            em.persist(member3);

            em.flush(); //1차 캐시
            em.clear();

            String query = "select m from Member m";
            List<Member> result = em.createQuery(query, Member.class)
                    .getResultList();

            for (Member member : result) {
                System.out.println("member = " + member.getUsername() + ", " + member.getTeam().getName());
            }

            tx.commit();
        }
```

```sql
Hibernate:
    /* select
        m
    from
        Member m */ select
            member0_.id as id1_0_,
            member0_.age as age2_0_,
            member0_.TEAM_ID as TEAM_ID5_0_,
            member0_.type as type3_0_,
            member0_.username as username4_0_
        from
            Member member0_
Hibernate:
    select
        team0_.id as id1_3_0_,
        team0_.name as name2_3_0_
    from
        Team team0_
    where
        team0_.id=?
member = 회원1, 팀A
member = 회원2, 팀A
Hibernate:
    select
        team0_.id as id1_3_0_,
        team0_.name as name2_3_0_
    from
        Team team0_
    where
        team0_.id=?
member = 회원3, 팀B
```

> 첫 번째 루프를 돌면서 프록시는 영속성 컨텍스트에게 데이터를 전달받는다.<br>
> 그렇게 "회원1, 팀A"는 SQL로 가져오며 "회원2, 팀A"는 1차캐시에서 가져온다.<br>
> 회원3은 "팀B" 소속이기 때문에 영속성 컨텍스트에 없기 때문에 SQL에서 가져온다.
> 쿼리가 총 3번 나간다. 회원이 많을수록 쿼리는 N+1이 된다.
> **보안방법으로는**

```java
String query = "select m from Member m join fetch m.team";
            List<Member> result = em.createQuery(query, Member.class)
                    .getResultList();

            for (Member member : result) {
                System.out.println("member = " + member.getUsername() + ", " + member.getTeam().getName());
            }
```

```sql
Hibernate:
    /* select
        m
    from
        Member m
    join
        fetch m.team */ select
            member0_.id as id1_0_0_,
            team1_.id as id1_3_1_,
            member0_.age as age2_0_0_,
            member0_.TEAM_ID as TEAM_ID5_0_0_,
            member0_.type as type3_0_0_,
            member0_.username as username4_0_0_,
            team1_.name as name2_3_1_
        from
            Member member0_
        inner join
            Team team1_
                on member0_.TEAM_ID=team1_.id
member = 회원1, 팀A
member = 회원2, 팀A
member = 회원3, 팀B
```

> join fetch로 한방쿼리가 나가며 프록시가 아니라 쿼리로 인해 실제 데이터가 담긴다.
> Lazy로 설정해도 join fetch가 우선순위가 높다.

### 컬렉션 패치 조인

- **일대다 관계, 컬렉션 페치 조인**
- [JPQL]

  ```sql
  select t
  from Team t join fetch t.members
  where t.name = '팀A'
  ```

- [SQL]
  ```sql
  SELECT T.*, M.*
  FROM TEAM T
  INNER JOIN MEMBER M ON T.ID=M.TEAM_ID
  WHERE T.NAME = '팀A'
  ```

```java
String query = "select t from Team t join fetch t.members";
            List<Team> result = em.createQuery(query, Team.class)
                    .getResultList();

            for (Team team : result) {
                System.out.println("team = " + team.getName() + "|members=" + team.getMembers().size());
            }
```

```sql
Hibernate:
    /* select
        t
    from
        Team t
    join
        fetch t.members */ select
            team0_.id as id1_3_0_,
            members1_.id as id1_0_1_,
            team0_.name as name2_3_0_,
            members1_.age as age2_0_1_,
            members1_.TEAM_ID as TEAM_ID5_0_1_,
            members1_.type as type3_0_1_,
            members1_.username as username4_0_1_,
            members1_.TEAM_ID as TEAM_ID5_0_0__,
            members1_.id as id1_0_0__
        from
            Team team0_
        inner join
            Member members1_
                on team0_.id=members1_.TEAM_ID
team = 팀A|members=2
team = 팀A|members=2
team = 팀B|members=1
```

> 팀A의 결과가 한번 더 출력되었다. 데이터가 더 많을 수록 결과는 더 불어날 수 있다.

![image](https://user-images.githubusercontent.com/90185805/153761101-3926be40-d5c7-4d03-a3b4-a734ed9ae7c5.png)

> 팀A의 입장에서는 member는 2명이 있다. 회원이 2명이 있기에 join을 하면 결과를 2번 만든다.

### 컬렉션 패치 조인 사용 코드

![image](https://user-images.githubusercontent.com/90185805/153761400-c70b3886-476d-4dc1-9dae-bcc7559d8ae0.png)

### 패치 조인과 DISTINCT

- SQL의 DISTINCT는 중복된 결과를 제거하는 명령
- JPQL의 DISTINCT 2가지 기능 제공

  - 1. SQL에 DISTINCT를 추가
  - 2. 애플리케이션에서 엔티티 중복 제거

```sql
    select distinct t
    from Team t join fetch t.members
    where t.name = ‘팀A’
```

- SQL에 DISTINCT를 추가하지만 데이터가 다르므로 SQL 결과에서 중복제거 실패
  ![image](https://user-images.githubusercontent.com/90185805/153761468-64ab7590-5eee-4228-9550-b3834d26a901.png)

- DISTINCT가 추가로 애플리케이션에서 중복 제거시도
- 같은 식별자를 가진 **Team 엔티티 제거**
  ![image](https://user-images.githubusercontent.com/90185805/153761656-86f9706a-1542-4611-9487-803a4aa3b2f7.png)

  [DISTINCT 추가시 결과]
  teamname = 팀A, team = Team@0x100
  -> username = 회원1, member = Member@0x200
  -> username = 회원2, member = Member@0x300

### 패치 조인과 일반 조인의 차이

- **일반 조인 실행시 연관된 엔티티를 함께 조회하지 않음**
- [JPQL]

  ```sql
  select t
  from Team t join t.members m
  where t.name = ‘팀A'
  ```

- [SQL]

  ```sql
  SELECT T.*
  FROM TEAM T
  INNER JOIN MEMBER M ON T.ID=M.TEAM_ID
  WHERE T.NAME = '팀A'
  ```

### 패치 조인과 일반 조인의 차이

- JPQL은 결과를 반환할 때 연관관계 고려X
- 단지 SELECT 절에 지정한 엔티티만 조회할 뿐
- 여기서는 팀 엔티티만 조회하고, 회원 엔티티는 조회X
- 패치 조인을 사용할 때만 연관된 엔티티도 함께 **조회(즉시 로딩)**
- **패치 조인은 객체 그래프를 SQL 한번에 조회하는 개념**

### 패치 조인 실행 예시

- 페치 조인은 연관된 엔티티를 함께 조회함
- [JPQL]
  ```sql
  select t
  from Team t join fetch t.members
  where t.name = ‘팀A'
  ```
- [SQL]

  ```sql
  SELECT T.*, M.*
  FROM TEAM T
  INNER JOIN MEMBER M ON T.ID=M.TEAM_ID
  WHERE T.NAME = '팀A'
  ```

### 페치 조인의 특징과 한계

- **페치 조인 대상에는 별칭을 줄 수 없다.**
  - 하이버네이트는 가능, 가급적 사용X
- **둘 이상의 컬렉션은 페치 조인 할 수 없다.**
- **컬렉션을 패치 조인하면 페이징 API(setFirstResult, setMaxResults)를 사용할 수 없다.**
  - 일대일, 다대일 같은 단일 값 연관 필드들은 페치 조인해도 페이징 가능
  - 하이버네이트는 경고 로그를 남기고 메모리에서 페이징(매우 위험)
- 연관된 엔티티들을 SQL 한 번으로 조회 - 성능 최적화
- 엔티티에 직접 적용하는 글로벌 로딩 전략보다 우선함
  - @OneToMany(fetch = FetchType.LAZY) //글로벌 로딩 전략
- 실무에서 글로벌 로딩 전략은 모두 지연 로딩
  - META-INF/persistence.xml
    ```xml
    <property name="hibernate.default_batch_fetch_size" value="100"/>
    ```
- 최적화가 필요한 곳은 패치 조인 적용

### 패치 조인 - 정리

- 모든 것을 패치 조인으로 해결할 수 는 없음
- 패치 조인은 객체 그래프를 유지할 때 사용하면 효과적
- 여러 테이블을 조인해서 엔티티가 가진 모양이 아닌 전혀 다른 결과를 내야 하면, 패치 조인 보다는 일반 조인을 사용하고 필요한 데이터들만 조회해서 DTO로 반환하는 것이 효과적

## JPQL - 다형성 쿼리

![image](https://user-images.githubusercontent.com/90185805/153762015-4977c243-dab3-470d-99a4-aa82265130e7.png)

### TYPE

- 조회 대상을 특정 자식으로 한정
- 예) Item 중에 Book, Movie를 조회해라
- [JPQL]

  ```sql
  select i from Item i
  where type(i) IN (Book, Movie)
  ```

- [SQL]

  ```sql
  select i from i
  where i.DTYPE in (‘B’, ‘M’)
  ```

### TREAT(JPA 2.1)

- 자바의 타입 캐스팅과 유사
- 상속 구조에서 부모 타입을 특정 자식 타입으로 다룰 때 사용
- FROM, WHERE, SELECT(하이버네이트 지원) 사용

- 예) 부모인 Item과 자식 Book이 있다.
- [JPQL]
  ```sql
  select i from Item i
  where treat(i as Book).auther = 'kim'
  ```
- [SQL]
  ```sql
  select i.\* from Item i
  where i.DTYPE = ‘B’ and i.auther = 'kim'
  ```

## JPQL - 엔티티 직접 사용

### 엔티티 직접 사용 - 기본 키 값

- JPQL에서 엔티티를 직접 사용하면 SQL에서 해당 엔티티의 기
  본 키 값을 사용
- [JPQL]

  ```sql
  select count(m.id) from Member m //엔티티의 아이디를 사용
  select count(m) from Member m //엔티티를 직접 사용
  ```

- [SQL](JPQL 둘다 같은 다음 SQL 실행)

  ```sql
  select count(m.id) as cnt from Member m
  ```

### 엔티티 직접 사용 - 기본 키 값

![image](https://user-images.githubusercontent.com/90185805/153762167-91611595-11b1-49a1-ae07-b8995f82e02a.png)

### 엔티티 직접 사용 - 외래 키 값

![image](https://user-images.githubusercontent.com/90185805/153762188-1874ae06-4036-4b5e-8145-1af96c0d69ef.png)

## JPQL - Named 쿼리

### Named 쿼리 - 정적 쿼리

- 미리 정의해서 이름을 부여해두고 사용하는 JPQL
- 정적 쿼리
- 어노테이션, XML에 정의
- 애플리케이션 로딩 시점에 초기화 후 재사용
- **애플리케이션 로딩 시점에 쿼리를 검증**

### Named 쿼리 - 어노테이션

```java
@Entity
@NamedQuery(
    name = "Member.findByUsername",
    query="select m from Member m where m.username = :username")
public class Member {
...
}
------------------
List<Member> resultList = em.createNamedQuery("Member.findByUsername", Member.class)
    .setParameter("username","회원1")
    .getResultList();
```

### Named 쿼리 - XML에 정의

### [META-INF/persistence.xml]

```xml
<persistence-unit name="jpabook" >
 <mapping-file>META-INF/ormMember.xml</mapping-file>
```

### [[META-INF/ormMember.xml]

```xml
<?xml version="1.0" encoding="UTF-8"?>
<entity-mappings xmlns="http://xmlns.jcp.org/xml/ns/persistence/orm" version="2.1">
    <named-query name="Member.findByUsername">
        <query><![CDATA[
            select m
            from Member m
            where m.username = :username
        ]]></query>
    </named-query>
    <named-query name="Member.count">
        <query>select count(m) from Member m</query>
    </named-query>
</entity-mappings>
```

### Named 쿼리 환경에 따른 설정

- XML이 항상 우선권을 가진다.
- 애플리케이션 운영 환경에 따라 다른 XML을 배포할 수 있다.

## JPQL - 벌크 연산

### 벌크 연산

- 재고가 10개 미만인 모든 상품의 가격을 10% 상승하려면?
- JPA 변경 감지 기능으로 실행하려면 너무 많은 SQL 실행
  - 1. 재고가 10개 미만인 상품을 리스트로 조회한다.
  - 2. 상품 엔티티의 가격을 10% 증가한다.
  - 3. 트랜잭션 커밋 시점에 변경감지가 동작한다.
- 변경된 데이터가 100건이라면 100번의 UPDATE SQL 실행

### 벌크 연산 예제

- 쿼리 한 번으로 여러 테이블 로우 변경(엔티티)
- **executeUpdate()의 결과는 영향받은 엔티티 수 반환**
- **UPDATE, DELETE 지원**
- **INSERT(insert into .. select, 하이버네이트 지원)**

```java
String qlString = "update Product p " +
                "set p.price = p.price * 1.1 " +
                "where p.stockAmount < :stockAmount";

int resultCount = em.createQuery(qlString)
                    .setParameter("stockAmount", 10)
                    .executeUpdate();
```

### 벌크 연산 주의

- 벌크 연산은 영속성 컨텍스트를 무시하고 데이터베이스에 직접 쿼리
  - 벌크 연산을 먼저 실행
  - 벌크 연산 수행 후 영속성 컨텍스트 초기화 (em.flush, em.clear)

---

# 참고

- [자바 ORM 표준 JPA 프로그래밍 - 기본편](https://www.inflearn.com/course/ORM-JPA-Basic/lecture/21683?tab=curriculum&volume=1.00&quality=auto)
